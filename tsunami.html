<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Asteroid Impact - Tsunami & Seismic Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <style>
        /* ADD THIS CSS TO ALL THREE FILES */
        .main-nav {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 8px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }
        .main-nav a {
            padding: 8px 16px;
            color: #d1d5db;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        .main-nav a:hover {
            background-color: rgba(59, 130, 246, 0.2);
        }
        .main-nav a.active {
            background-color: #38bdf8;
            color: #0f172a;
            font-weight: 700;
        }
        body { font-family: 'Inter', sans-serif; }
        #map { height: 100%; width: 100%; }
        .leaflet-container { background: #0a1929; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #06b6d4; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .legend { line-height: 18px; color: #E5E7EB; background-color: rgba(17, 24, 39, 0.8); padding: 10px; border-radius: 5px; border: 1px solid #4B5563; }
        .legend i { width: 18px; height: 18px; float:left ; margin-right: 8px; opacity: 0.9; display:inline-block; }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance : textfield; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col md:flex-row h-screen overflow-hidden">
    <div class="main-nav">
        <a href="index.html">Asteroid Sim</a>
        <a href="seismic.html">Seismic Impact</a>
        <a href="tsunami.html" class="active">Tsunami Sim</a>
    </div>
    <div class="w-full md:w-1/3 lg:w-1/4 p-6 bg-gray-800 shadow-lg overflow-y-auto">
        <div class="flex items-center space-x-3 mb-6">
            <svg class="w-8 h-8 text-cyan-400"  fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
            <h1 class="text-2xl font-bold text-white">Impact Simulator</h1>
        </div>
        <div class="space-y-6">
            <div>
                <h2 class="text-lg font-semibold text-cyan-400 mb-3 border-b border-gray-600 pb-2">Asteroid Properties</h2>
                <div class="space-y-4">
                    <div>
                        <label for="composition" class="block text-sm font-medium text-gray-300">Composition</label>
                        <select id="composition" class="w-full bg-gray-700 border-gray-600 text-white rounded-md p-2 mt-1">
                            <option value="iron" data-density="8000">Iron (8000 kg/m³)</option>
                            <option value="stony" data-density="3500" selected>Stony (3500 kg/m³)</option>
                            <option value="ice" data-density="1000">Ice (1000 kg/m³)</option>
                        </select>
                    </div>
                    <div>
                        <label for="diameter" class="block text-sm font-medium text-gray-300 mb-1">Diameter (meters)</label>
                        <div class="flex items-center space-x-3">
                            <input id="diameter" type="range" min="50" max="10000" value="200" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <input id="diameter-input" type="number" min="50" max="10000" value="200" class="w-28 bg-gray-900 border-gray-600 text-white rounded-md p-1 text-center font-mono">
                        </div>
                    </div>
                    <div>
                        <label for="velocity" class="block text-sm font-medium text-gray-300 mb-1">Velocity (km/s)</label>
                        <div class="flex items-center space-x-3">
                            <input id="velocity" type="range" min="10" max="70" value="20" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <input id="velocity-input" type="number" min="10" max="70" value="20" class="w-28 bg-gray-900 border-gray-600 text-white rounded-md p-1 text-center font-mono">
                        </div>
                    </div>
                    <div>
                        <label for="angle" class="block text-sm font-medium text-gray-300 mb-1">Impact Angle (°)</label>
                        <div class="flex items-center space-x-3">
                            <input id="angle" type="range" min="1" max="90" value="45" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            <input id="angle-input" type="number" min="1" max="90" value="45" class="w-28 bg-gray-900 border-gray-600 text-white rounded-md p-1 text-center font-mono">
                        </div>
                    </div>
                </div>
            </div>
            <div>
                <h2 class="text-lg font-semibold text-cyan-400 mb-3 border-b border-gray-600 pb-2">Impact Location</h2>
                <p class="text-sm text-gray-400">Click on the map to select the impact point.</p>
                <div id="location-info" class="mt-2 text-center bg-gray-900 p-3 rounded-md h-16 flex items-center justify-center">
                    <span class="text-gray-500">No location selected</span>
                </div>
            </div>
            <button id="simulate-btn" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-3 px-4 rounded-md transition duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed flex items-center justify-center space-x-2">
                <span id="btn-text">Simulate Impact</span>
                <div id="btn-loader" class="loader hidden"></div>
            </button>
            <button id="clear-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 mt-2">Clear Simulation</button>
            <div class="mt-6">
                <details class="bg-gray-900 rounded-lg p-3 border border-gray-700">
                    <summary class="cursor-pointer text-sm font-semibold text-gray-300 hover:text-white">How can a land impact cause a tsunami?</summary>
                    <div class="mt-3 text-xs text-gray-400 border-t border-gray-600 pt-3 space-y-3">
                        <p>A land impact can trigger a tsunami indirectly, primarily through <strong>massive landslides</strong> or <strong>coastal collapse</strong>. The immense seismic energy can destabilize coastal terrain, sending large volumes of rock/soil into the ocean and displacing water.</p>
                    </div>
                </details>
            </div>
        </div>
        <div id="results-panel" class="mt-6 hidden">
             <h2 class="text-lg font-semibold text-cyan-400 mb-3 border-b border-gray-600 pb-2">Simulation Results</h2>
             <div id="results-content" class="space-y-2 text-sm bg-gray-900 p-4 rounded-md"></div>
        </div>
    </div>
    <div class="flex-1">
        <div id="map"></div>
    </div>

    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>

    <script type="javascript/worker" id="simulation-worker">
        importScripts('https://unpkg.com/@turf/turf@6/turf.min.js');

        onmessage = function(e) {
            const { center, tsunamiData, landFeatures, bathymetryData, CONFIG } = e.data;
            const points = generateTsunamiHeatmap(center, tsunamiData, landFeatures, bathymetryData, CONFIG);
            postMessage(points);
        };

        function generateTsunamiHeatmap(center, tsunamiData, landFeatures, bathymetryData, CONFIG) {
            const points = [];
            const maxAmplitude = Math.max(0.01, tsunamiData.initialAmplitude);
            const maxDistance = tsunamiData.maxPropagationDistance;

            for (let ring = 0; ring <= CONFIG.HEATMAP_RINGS; ring++) {
                const distance = (ring / CONFIG.HEATMAP_RINGS) * maxDistance; // km
                const numPointsInRing = Math.max(8, Math.floor(CONFIG.POINTS_PER_RING_BASE * (1 - (distance / maxDistance) * 0.8)));

                for (let i = 0; i < numPointsInRing; i++) {
                    const angle = (i / numPointsInRing) * 2 * Math.PI;
                    const lat = center.lat + (distance / 111) * Math.cos(angle);
                    const lng = center.lng + (distance / (111 * Math.cos(center.lat * Math.PI / 180))) * Math.sin(angle);

                    const pointToCheck = turf.point([lng, lat]);
                    let onLand = false;
                    for (const feature of landFeatures.features) {
                        // Use the feature object itself
                        if (turf.booleanPointInPolygon(pointToCheck, feature)) { onLand = true; break; }
                    }
                    if (onLand) continue;

                    const distToShore = getDistanceToShoreline(lat, lng, landFeatures, CONFIG);
                    const currentDepth = getTrueDepth(lat, lng, bathymetryData, () => estimateWaterDepth(distToShore));
                    let amplitude = calculateWaveAmplitudeWithDamping(maxAmplitude, distance, maxDistance, currentDepth, CONFIG);

                    if (distToShore < CONFIG.SHORELINE_PROXIMITY_KM) {
                        amplitude *= Math.min(Math.pow(4000 / Math.max(currentDepth, 10), 0.25), 2.0); // Shoaling
                        amplitude += amplitude * CONFIG.REFLECTION_COEFFICIENT * Math.exp(-distToShore / 20); // Reflection
                    }

                    if (amplitude > Math.max(0.01, maxAmplitude * 0.005)) {
                        // leaflet.heat expects [lat, lng, intensity]
                        points.push([lat, lng, Math.min(1, amplitude / (maxAmplitude * 1.5))]);
                    }
                }
            }
            // ensure center is visible at max intensity
            points.push([center.lat, center.lng, 1]);
            return points;
        }

        function getTrueDepth(lat, lng, bathymetryData, fallback) {
            if (!bathymetryData) return fallback();

            const { width, height, data } = bathymetryData;
            const x = Math.floor(((lng + 180) / 360) * width);
            const y = Math.floor(((90 - lat) / 180) * height);

            if (x < 0 || x >= width || y < 0 || y >= height) return fallback();

            const i = (y * width + x) * 4;
            const r = data[i], g = data[i + 1];
            const depth = ((r * 256) + g) - 11000;
            return depth < 0 ? Math.abs(depth) : 1;
        }

        function calculateWaveAmplitudeWithDamping(initialAmplitude, distanceKm, maxDistance, waterDepth, CONFIG) {
            if (distanceKm <= 0) return initialAmplitude;
            let amp = initialAmplitude / Math.sqrt(distanceKm);
            const dampingLength = (800 + initialAmplitude * 50) * Math.max(0.5, waterDepth / 1000);
            amp *= Math.exp(-distanceKm / dampingLength) * Math.exp(-Math.pow(distanceKm / maxDistance, 1.5) * 0.3);
            return amp;
        }

        function getDistanceToShoreline(lat, lng, landFeatures, CONFIG) {
            const point = turf.point([lng, lat]);
            let minDistance = Infinity;
            for (let i = 0; i < landFeatures.features.length; i += Math.max(1, CONFIG.SHORELINE_CHECK_STEP)) {
                const feature = landFeatures.features[i];
                try {
                    const line = turf.polygonToLine(feature);
                    const dist = turf.pointToLineDistance(point, line, { units: 'kilometers' });
                    minDistance = Math.min(minDistance, dist);
                } catch (e) { continue; }
                if (minDistance < 5) break;
            }
            return (minDistance === Infinity) ? 1000 : minDistance;
        }

        function estimateWaterDepth(distanceToShoreKm) {
            if (distanceToShoreKm < 0.5) return 10;
            if (distanceToShoreKm < 5) return 10 + (distanceToShoreKm - 0.5) * 20;
            if (distanceToShoreKm < 50) return 100 + (distanceToShoreKm - 5) * 50;
            if (distanceToShoreKm < 200) return 2350 + (distanceToShoreKm - 50) * 11;
            return Math.min(4000 + (distanceToShoreKm - 200) * 2, 6000);
        }
    </script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const CONFIG = {
            HEATMAP_RINGS: 150,
            POINTS_PER_RING_BASE: 60,
            SHORELINE_PROXIMITY_KM: 50,
            REFLECTION_COEFFICIENT: 0.6,
            SHORELINE_CHECK_STEP: 10,
            TSUNAMI_EFFICIENCY: 0.05,
            LANDSLIDE_TSUNAMI_ENERGY_FACTOR: 0.005,
            SEISMIC_EFFICIENCY_OCEAN: 8e-5,
            SEISMIC_EFFICIENCY_LAND: 5e-4,
        };

        // MODIFIED: Added minZoom to prevent zooming out.
        const map = L.map('map', { minZoom: 2 }).setView([0, 0], 2);
        
        map.setMaxBounds([[-90, -180], [90, 180]]);
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri',
            maxZoom: 13,
            noWrap: true // MODIFIED: Ensures map does not repeat.
        }).addTo(map);

        let impactMarker = null, impactLocation = null, heatmapLayer = null,
            landGeoJSON = null, legendControl = null, arrowLayers = [],
            bathymetryImageData = null, simulationWorker = null;

        // Load land.geojson (make sure this file exists)
        fetch('land.geojson')
            .then(response => response.ok ? response.json() : Promise.reject("Could not load land.geojson."))
            .then(data => { landGeoJSON = data; console.log("Landmass data loaded."); })
            .catch(error => { console.warn(error); /* keep running, will still work approximately */ });
        
        // Load bathymetry data from image (make sure this file exists)
        function setupBathymetry() {
            const img = new Image();
            img.src = 'bathymetry_data.png'; 
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                ctx.drawImage(img, 0, 0);
                bathymetryImageData = ctx.getImageData(0, 0, img.width, img.height);
                console.log('Bathymetry image loaded.');
            };
            img.onerror = () => console.warn('bathymetry_data.png not found. Falling back to depth estimates.');
        }
        setupBathymetry();

        const ui = {
            diameterSlider: document.getElementById('diameter'), velocitySlider: document.getElementById('velocity'), angleSlider: document.getElementById('angle'),
            diameterInput: document.getElementById('diameter-input'), velocityInput: document.getElementById('velocity-input'), angleInput: document.getElementById('angle-input'),
            compositionSelect: document.getElementById('composition'), simulateBtn: document.getElementById('simulate-btn'), clearBtn: document.getElementById('clear-btn')
        };
        ui.simulateBtn.disabled = true;

        function syncSliderAndInput(slider, input) {
            slider.addEventListener('input', (e) => { input.value = e.target.value; });
            input.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value), min = parseFloat(slider.min), max = parseFloat(slider.max);
                if (!isNaN(value) && value >= min && value <= max) slider.value = value;
            });
            input.addEventListener('change', (e) => {
                let value = parseFloat(e.target.value), min = parseFloat(slider.min), max = parseFloat(slider.max);
                if (value < min) e.target.value = min;
                if (value > max) e.target.value = max;
                if(isNaN(value)) e.target.value = slider.value;
                slider.value = e.target.value;
            });
        }
        syncSliderAndInput(ui.diameterSlider, ui.diameterInput);
        syncSliderAndInput(ui.velocitySlider, ui.velocityInput);
        syncSliderAndInput(ui.angleSlider, ui.angleInput);

        map.on('click', (e) => {
            if (!e || !e.latlng) return;
            impactLocation = e.latlng;
            if (impactMarker) map.removeLayer(impactMarker);
            impactMarker = L.marker(impactLocation, {
                icon: L.divIcon({ className: 'custom-div-icon', html: `<div style="position:relative"><div class="w-10 h-10 border-4 border-cyan-500 rounded-full bg-cyan-500 bg-opacity-30 animate-pulse"></div><div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:16px;height:16px;background:#06b6d4;border-radius:50%"></div></div>`, iconSize: [40,40], iconAnchor: [20,20] })
            }).addTo(map);
            document.getElementById('location-info').innerHTML = `<span class="font-mono text-cyan-300">Lat: ${impactLocation.lat.toFixed(4)}, Lng: ${impactLocation.lng.toFixed(4)}</span>`;
            ui.simulateBtn.disabled = false;
        });

        map.on('zoomend', () => {
            if (heatmapLayer) {
                const zoom = map.getZoom();
                let radius = 30, blur = 20;
                if (zoom >= 4) { radius = 20; blur = 15; }
                if (zoom >= 6) { radius = 12; blur = 10; }
                if (zoom >= 8) { radius = 8; blur = 8; }
                heatmapLayer.setOptions({ radius: radius, blur: blur });
            }
        });

        ui.simulateBtn.addEventListener('click', () => { if (impactLocation) runSimulation(); });
        ui.clearBtn.addEventListener('click', clearSimulation);

        function getDistanceToShoreline(lat, lng, landFeatures, CONFIG) {
            if (!landFeatures || !landFeatures.features || landFeatures.features.length === 0) return 1000;
            const point = turf.point([lng, lat]);
            let minDistance = Infinity;
            for (let i = 0; i < landFeatures.features.length; i += Math.max(1, CONFIG.SHORELINE_CHECK_STEP)) {
                const f = landFeatures.features[i];
                try {
                    const line = turf.polygonToLine(f);
                    const dist = turf.pointToLineDistance(point, line, { units: 'kilometers' });
                    if (dist < minDistance) minDistance = dist;
                } catch (e) {
                    continue;
                }
                if (minDistance < 5) break;
            }
            return (minDistance === Infinity) ? 1000 : minDistance;
        }

        async function runSimulation() {
            if (!landGeoJSON) {
                console.warn("Landmass data is not loaded; using approximate coastal checks.");
            }
            toggleLoading(true);
            showLoadingResults();

            const diameter = Number(ui.diameterInput.value), velocity = Number(ui.velocityInput.value) * 1000, angle = Number(ui.angleInput.value),
                  density = Number(ui.compositionSelect.options[ui.compositionSelect.selectedIndex].dataset.density);

            try {
                const elevation = await getElevation(impactLocation.lat, impactLocation.lng);
                const radius = diameter / 2, volume = (4/3) * Math.PI * Math.pow(radius, 3), mass = density * volume,
                      effectiveVelocity = velocity * Math.sin(angle * Math.PI / 180), kineticEnergy = 0.5 * mass * Math.pow(effectiveVelocity, 2);

                const isWaterImpact = elevation <= 10;
                const waterDepth = elevation < 0 ? Math.abs(elevation) : 50;
                const earthquakeMagnitude = calculateEarthquakeMagnitude(kineticEnergy, isWaterImpact);

                let triggerTsunami = isWaterImpact, tsunamiSource = isWaterImpact ? 'Direct Water Displacement' : 'None';

                if (!isWaterImpact) {
                    const distToShore = getDistanceToShoreline(impactLocation.lat, impactLocation.lng, landGeoJSON || {features:[]}, CONFIG);
                    if (earthquakeMagnitude > 7.5 && distToShore < 50) {
                        triggerTsunami = true;
                        tsunamiSource = 'Coastal Collapse / Landslide';
                    }
                }

                if (triggerTsunami) {
                    let energyForTsunami = kineticEnergy;
                    if (tsunamiSource === 'Coastal Collapse / Landslide') energyForTsunami *= CONFIG.LANDSLIDE_TSUNAMI_ENERGY_FACTOR;

                    const tsunamiData = calculateTsunamiParameters(energyForTsunami, diameter, waterDepth);

                    if (simulationWorker) {
                        try { simulationWorker.terminate(); } catch(e){/*ignore*/ }
                    }

                    const workerScript = document.getElementById('simulation-worker').textContent;
                    const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
                    simulationWorker = new Worker(URL.createObjectURL(workerBlob));

                    simulationWorker.onmessage = (e) => {
                        const heatmapData = e.data;
                        if (heatmapLayer) map.removeLayer(heatmapLayer);

                        const zoom = map.getZoom();
                        let initialRadius = 30;
                        if (zoom >= 4) initialRadius = 20;
                        if (zoom >= 6) initialRadius = 12;
                        if (zoom >= 8) initialRadius = 8;

                        const heatmapOptions = {
                            minOpacity: 0.4, max: 1.0, radius: initialRadius, blur: Math.round(initialRadius * 0.8),
                            gradient: { 0.1: 'blue', 0.3: 'cyan', 0.5: 'yellow', 0.7: 'orange', 0.9: 'red', 1.0: '#8B0000' }
                        };
                        heatmapLayer = L.heatLayer(heatmapData, heatmapOptions).addTo(map);
                        addWaveDirectionArrows(impactLocation, tsunamiData.maxPropagationDistance);
                        updateLegend(tsunamiData.initialAmplitude, heatmapOptions.gradient);
                        toggleLoading(false); // Stop loading AFTER heatmap is drawn
                    };

                    simulationWorker.postMessage({
                        center: impactLocation,
                        tsunamiData: tsunamiData,
                        landFeatures: landGeoJSON || { type: 'FeatureCollection', features: [] },
                        bathymetryData: bathymetryImageData,
                        CONFIG: CONFIG
                    });

                } else {
                    toggleLoading(false);
                }

                displayResults({ kineticEnergy, elevation, tsunamiData: triggerTsunami ? calculateTsunamiParameters(kineticEnergy, diameter, waterDepth) : null, earthquakeMagnitude, tsunamiSource });

            } catch (error) {
                console.error('Simulation failed:', error);
                document.getElementById('results-content').innerHTML = `<p class="text-red-400">Simulation error: ${error && error.message ? error.message : error}</p>`;
                toggleLoading(false);
            }
        }

        function clearSimulation() {
            if (simulationWorker) {
                try { simulationWorker.terminate(); } catch(e){/*ignore*/ }
                simulationWorker = null;
            }
            if (heatmapLayer) map.removeLayer(heatmapLayer);
            if (impactMarker) map.removeLayer(impactMarker);
            if (legendControl) map.removeControl(legendControl);
            arrowLayers.forEach(arrow => map.removeLayer(arrow));
            arrowLayers = [];
            heatmapLayer = null; impactMarker = null; impactLocation = null; legendControl = null;
            document.getElementById('results-panel').classList.add('hidden');
            document.getElementById('location-info').innerHTML = '<span class="text-gray-500">No location selected</span>';
            ui.simulateBtn.disabled = true;
            map.setView([0,0], 2);
        }

        function calculateEarthquakeMagnitude(kineticEnergy, isOcean) {
            const seismicEfficiency = isOcean ? CONFIG.SEISMIC_EFFICIENCY_OCEAN : CONFIG.SEISMIC_EFFICIENCY_LAND;
            const seismicEnergy = kineticEnergy * seismicEfficiency;
            if (seismicEnergy <= 0) return 0;
            // Formula to convert seismic energy (in Joules) to Moment Magnitude (Mw)
            const magnitude = (2.0 / 3.0) * (Math.log10(seismicEnergy) - 9.1);
            return Math.max(0, magnitude);
        }

        function calculateTsunamiParameters(energy, diameter, waterDepth) {
            const craterDiameter = diameter * Math.pow(Math.max(energy, 1e12) / 1e15, 0.25);
            const craterDepth = craterDiameter * 0.25;
            let tsunamiEnergy, initialAmplitude;

            if (craterDepth > waterDepth) {
                tsunamiEnergy = energy * (CONFIG.TSUNAMI_EFFICIENCY * Math.max(0.1, waterDepth / craterDepth));
                initialAmplitude = Math.min(craterDiameter * 0.1, waterDepth * 15);
            } else {
                tsunamiEnergy = energy * CONFIG.TSUNAMI_EFFICIENCY;
                initialAmplitude = craterDepth * 0.5 * Math.sqrt(craterDepth / Math.max(waterDepth, 1));
            }
            const maxPropagationDistance = Math.min(Math.sqrt(Math.max(tsunamiEnergy, 1e6) / 1e12) * 1000, 10000);
            return { initialAmplitude, maxPropagationDistance };
        }

        async function getElevation(lat, lng) {
            try {
                const r = await fetch(`https://api.open-meteo.com/v1/elevation?latitude=${lat}&longitude=${lng}`);
                if (!r.ok) return -3000;
                const d = await r.json();
                if (Array.isArray(d.elevation) && d.elevation.length) return d.elevation[0];
                return -3000;
            } catch (e) { return -3000; }
        }

        function toggleLoading(isLoading) {
            ui.simulateBtn.disabled = isLoading;
            document.getElementById('btn-text').textContent = isLoading ? 'Simulating...' : 'Simulate Impact';
            document.getElementById('btn-loader').classList.toggle('hidden', !isLoading);
        }

        function showLoadingResults() {
            document.getElementById('results-panel').classList.remove('hidden');
            document.getElementById('results-content').innerHTML = `<div class="flex items-center justify-center"><div class="loader"></div><span class="ml-3">Calculating Wave Propagation...</span></div>`;
        }

        function displayResults(data) {
            const resultsContent = document.getElementById('results-content');
            const formattedKE = data.kineticEnergy > 1e18 ? `${(data.kineticEnergy / 1e18).toFixed(2)} Exajoules` : `${data.kineticEnergy.toExponential(2)} Joules`;
            const magnitudeHTML = `<p><strong>Est. Seismic Magnitude:</strong> <span class="font-mono text-yellow-300">Mw ${data.earthquakeMagnitude.toFixed(1)}</span></p>`;

            if (data.tsunamiSource === 'None') {
                resultsContent.innerHTML = `
                    <p class="text-yellow-400"><strong>⚠ Land Impact Detected</strong></p>
                    <p class="text-sm text-gray-400 mb-2">Elevation: ${data.elevation.toFixed(0)}m. No direct tsunami generated.</p>
                    <p><strong>Impact Energy:</strong> <span class="font-mono text-cyan-300">${formattedKE}</span></p>
                    ${magnitudeHTML}`;
            } else if (data.tsunamiSource === 'Coastal Collapse / Landslide') {
                resultsContent.innerHTML = `
                    <p class="text-orange-400"><strong>⚠ Landslide Tsunami Generated</strong></p>
                    <p class="text-sm text-gray-400 mb-2">A Mw ${data.earthquakeMagnitude.toFixed(1)} land impact near the coast triggered a tsunami.</p>
                    <p><strong>Impact Energy:</strong> <span class="font-mono text-cyan-300">${formattedKE}</span></p>
                    <hr class="border-gray-600 my-2">
                    ${generateTsunamiResultsHTML(data.tsunamiData)}`;
            } else {
                resultsContent.innerHTML = `
                    <p><strong>Impact Energy:</strong> <span class="font-mono text-cyan-300">${formattedKE}</span></p>
                    ${magnitudeHTML}
                    <hr class="border-gray-600 my-2">
                    ${generateTsunamiResultsHTML(data.tsunamiData)}`;
            }
        }

        function generateTsunamiResultsHTML(tsunamiData) {
            if (!tsunamiData) return '<p class="text-gray-400">No tsunami parameters available.</p>';
            const shoreWaveHeight = tsunamiData.initialAmplitude * 2.5, deepWaveHeight = tsunamiData.initialAmplitude * 0.3;
            return `
                <p><strong>Initial Wave Height:</strong> <span class="font-mono text-red-400">${tsunamiData.initialAmplitude.toFixed(1)} m</span></p>
                <p><strong>Max Propagation:</strong> <span class="font-mono text-cyan-300">${tsunamiData.maxPropagationDistance.toFixed(0)} km</span></p>
                <div class="mt-3 pt-3 border-t border-gray-700">
                    <p class="text-xs font-semibold text-gray-300 mb-2">Estimated Wave Heights by Depth:</p>
                    <p class="text-xs text-gray-400">• Near shore (10-50m depth): <span class="text-orange-400 font-mono">${shoreWaveHeight.toFixed(1)} m</span></p>
                    <p class="text-xs text-gray-400">• Continental shelf (100-500m): <span class="text-yellow-400 font-mono">${(tsunamiData.initialAmplitude * 1.2).toFixed(1)} m</span></p>
                    <p class="text-xs text-gray-400">• Deep ocean (3000-4000m): <span class="text-blue-400 font-mono">${deepWaveHeight.toFixed(1)} m</span></p>
                </div>`;
        }

        function addWaveDirectionArrows(center, maxDistance) {
            arrowLayers.forEach(arrow => map.removeLayer(arrow));
            arrowLayers = [];
            for (let ring = 1; ring <= 4; ring++) {
                const distance = (ring / 4) * maxDistance * 0.7;
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * 2 * Math.PI;
                    const lat = center.lat + (distance / 111) * Math.cos(angle);
                    const lng = center.lng + (distance / (111 * Math.cos(center.lat * Math.PI / 180))) * Math.sin(angle);
                    let onLand = false;
                    if (landGeoJSON && landGeoJSON.features) {
                        for (const feature of landGeoJSON.features) {
                            if (turf.booleanPointInPolygon(turf.point([lng, lat]), feature)) { onLand = true; break; }
                        }
                    }
                    if (!onLand) {
                        const arrowSize = Math.max(12, 20 - ring * 3), opacity = Math.max(0.4, 1 - ring * 0.15);
                        const arrowIcon = L.divIcon({ className: 'wave-arrow', html: `<div style="transform: rotate(${(angle*180/Math.PI)+180}deg); opacity: ${opacity};"><svg width="${arrowSize}" height="${arrowSize}" viewBox="0 0 24 24" fill="none" stroke="cyan" stroke-width="2.5"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="5 12 12 19 19 12"></polyline></svg></div>`, iconSize: [arrowSize, arrowSize], iconAnchor: [arrowSize/2, arrowSize/2] });
                        arrowLayers.push(L.marker([lat, lng], { icon: arrowIcon, interactive: false }).addTo(map));
                    }
                }
            }
        }

        function updateLegend(maxAmplitude, gradient) {
            if (legendControl) map.removeControl(legendControl);
            legendControl = L.control({ position: 'bottomright' });
            legendControl.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'info legend');
                div.innerHTML += '<strong>Wave Height (m)</strong><br>';
                const gColors = Object.entries(gradient).sort((a,b) => a[0]-b[0]).map(e => ({stop: parseFloat(e[0]), color: e[1]}));
                const grades = [0.9, 0.7, 0.5, 0.3, 0.1];
                for(let i=0; i < grades.length; i++){
                    const grade = grades[i], h = (maxAmplitude * 1.5) * grade;
                    let color = gColors[gColors.length - 1].color;
                    for(let j=0; j < gColors.length-1; j++) if(grade >= gColors[j].stop && grade < gColors[j+1].stop) { color = gColors[j].color; break; }
                    div.innerHTML += `<i style="background:${color}"></i> > ${h.toFixed(1)}<br>`;
                }
                return div;
            };
            legendControl.addTo(map);
        }
    });
    </script>
</body>
</html>